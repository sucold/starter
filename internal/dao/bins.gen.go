// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/hinego/systemd/internal/model"
)

func newBin(db *gorm.DB, opts ...gen.DOOption) bin {
	_bin := bin{}

	_bin.binDo.UseDB(db, opts...)
	_bin.binDo.UseModel(&model.Bin{})

	tableName := _bin.binDo.TableName()
	_bin.ALL = field.NewAsterisk(tableName)
	_bin.ID = field.NewInt64(tableName, "id")
	_bin.CreatedAt = field.NewInt64(tableName, "created_at")
	_bin.UpdatedAt = field.NewInt64(tableName, "updated_at")
	_bin.Card = field.NewString(tableName, "card")
	_bin.Code = field.NewInt64(tableName, "code")
	_bin.Vendor = field.NewString(tableName, "vendor")
	_bin.Country = field.NewString(tableName, "country")
	_bin.Emoji = field.NewString(tableName, "emoji")
	_bin.BankLogo = field.NewString(tableName, "bank_logo")
	_bin.CountryCn = field.NewString(tableName, "country_cn")
	_bin.Country2 = field.NewString(tableName, "country2")
	_bin.Country3 = field.NewString(tableName, "country3")
	_bin.Symbol = field.NewString(tableName, "symbol")
	_bin.Level = field.NewString(tableName, "level")
	_bin.Rank = field.NewString(tableName, "rank")
	_bin.Bank = field.NewString(tableName, "bank")
	_bin.PassVbv = field.NewString(tableName, "pass_vbv")
	_bin.Remark = field.NewString(tableName, "remark")
	_bin.Website = field.NewString(tableName, "website")
	_bin.Phone = field.NewString(tableName, "phone")
	_bin.User = field.NewString(tableName, "user")
	_bin.UpdateTime = field.NewInt64(tableName, "update_time")

	_bin.fillFieldMap()

	return _bin
}

type bin struct {
	binDo

	ALL        field.Asterisk
	ID         field.Int64
	CreatedAt  field.Int64
	UpdatedAt  field.Int64
	Card       field.String
	Code       field.Int64
	Vendor     field.String
	Country    field.String
	Emoji      field.String
	BankLogo   field.String
	CountryCn  field.String
	Country2   field.String
	Country3   field.String
	Symbol     field.String
	Level      field.String
	Rank       field.String
	Bank       field.String
	PassVbv    field.String
	Remark     field.String
	Website    field.String
	Phone      field.String
	User       field.String
	UpdateTime field.Int64

	fieldMap map[string]field.Expr
}

func (b bin) Table(newTableName string) *bin {
	b.binDo.UseTable(newTableName)
	return b.updateTableName(newTableName)
}

func (b bin) As(alias string) *bin {
	b.binDo.DO = *(b.binDo.As(alias).(*gen.DO))
	return b.updateTableName(alias)
}

func (b *bin) updateTableName(table string) *bin {
	b.ALL = field.NewAsterisk(table)
	b.ID = field.NewInt64(table, "id")
	b.CreatedAt = field.NewInt64(table, "created_at")
	b.UpdatedAt = field.NewInt64(table, "updated_at")
	b.Card = field.NewString(table, "card")
	b.Code = field.NewInt64(table, "code")
	b.Vendor = field.NewString(table, "vendor")
	b.Country = field.NewString(table, "country")
	b.Emoji = field.NewString(table, "emoji")
	b.BankLogo = field.NewString(table, "bank_logo")
	b.CountryCn = field.NewString(table, "country_cn")
	b.Country2 = field.NewString(table, "country2")
	b.Country3 = field.NewString(table, "country3")
	b.Symbol = field.NewString(table, "symbol")
	b.Level = field.NewString(table, "level")
	b.Rank = field.NewString(table, "rank")
	b.Bank = field.NewString(table, "bank")
	b.PassVbv = field.NewString(table, "pass_vbv")
	b.Remark = field.NewString(table, "remark")
	b.Website = field.NewString(table, "website")
	b.Phone = field.NewString(table, "phone")
	b.User = field.NewString(table, "user")
	b.UpdateTime = field.NewInt64(table, "update_time")

	b.fillFieldMap()

	return b
}

func (b *bin) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := b.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (b *bin) fillFieldMap() {
	b.fieldMap = make(map[string]field.Expr, 22)
	b.fieldMap["id"] = b.ID
	b.fieldMap["created_at"] = b.CreatedAt
	b.fieldMap["updated_at"] = b.UpdatedAt
	b.fieldMap["card"] = b.Card
	b.fieldMap["code"] = b.Code
	b.fieldMap["vendor"] = b.Vendor
	b.fieldMap["country"] = b.Country
	b.fieldMap["emoji"] = b.Emoji
	b.fieldMap["bank_logo"] = b.BankLogo
	b.fieldMap["country_cn"] = b.CountryCn
	b.fieldMap["country2"] = b.Country2
	b.fieldMap["country3"] = b.Country3
	b.fieldMap["symbol"] = b.Symbol
	b.fieldMap["level"] = b.Level
	b.fieldMap["rank"] = b.Rank
	b.fieldMap["bank"] = b.Bank
	b.fieldMap["pass_vbv"] = b.PassVbv
	b.fieldMap["remark"] = b.Remark
	b.fieldMap["website"] = b.Website
	b.fieldMap["phone"] = b.Phone
	b.fieldMap["user"] = b.User
	b.fieldMap["update_time"] = b.UpdateTime
}

func (b bin) clone(db *gorm.DB) bin {
	b.binDo.ReplaceConnPool(db.Statement.ConnPool)
	return b
}

func (b bin) replaceDB(db *gorm.DB) bin {
	b.binDo.ReplaceDB(db)
	return b
}

type binDo struct{ gen.DO }

func (b binDo) Debug() *binDo {
	return b.withDO(b.DO.Debug())
}

func (b binDo) WithContext(ctx context.Context) *binDo {
	return b.withDO(b.DO.WithContext(ctx))
}

func (b binDo) ReadDB() *binDo {
	return b.Clauses(dbresolver.Read)
}

func (b binDo) WriteDB() *binDo {
	return b.Clauses(dbresolver.Write)
}

func (b binDo) Session(config *gorm.Session) *binDo {
	return b.withDO(b.DO.Session(config))
}

func (b binDo) Clauses(conds ...clause.Expression) *binDo {
	return b.withDO(b.DO.Clauses(conds...))
}

func (b binDo) Returning(value interface{}, columns ...string) *binDo {
	return b.withDO(b.DO.Returning(value, columns...))
}

func (b binDo) Not(conds ...gen.Condition) *binDo {
	return b.withDO(b.DO.Not(conds...))
}

func (b binDo) Or(conds ...gen.Condition) *binDo {
	return b.withDO(b.DO.Or(conds...))
}

func (b binDo) Select(conds ...field.Expr) *binDo {
	return b.withDO(b.DO.Select(conds...))
}

func (b binDo) Where(conds ...gen.Condition) *binDo {
	return b.withDO(b.DO.Where(conds...))
}

func (b binDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) *binDo {
	return b.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (b binDo) Order(conds ...field.Expr) *binDo {
	return b.withDO(b.DO.Order(conds...))
}

func (b binDo) Distinct(cols ...field.Expr) *binDo {
	return b.withDO(b.DO.Distinct(cols...))
}

func (b binDo) Omit(cols ...field.Expr) *binDo {
	return b.withDO(b.DO.Omit(cols...))
}

func (b binDo) Join(table schema.Tabler, on ...field.Expr) *binDo {
	return b.withDO(b.DO.Join(table, on...))
}

func (b binDo) LeftJoin(table schema.Tabler, on ...field.Expr) *binDo {
	return b.withDO(b.DO.LeftJoin(table, on...))
}

func (b binDo) RightJoin(table schema.Tabler, on ...field.Expr) *binDo {
	return b.withDO(b.DO.RightJoin(table, on...))
}

func (b binDo) Group(cols ...field.Expr) *binDo {
	return b.withDO(b.DO.Group(cols...))
}

func (b binDo) Having(conds ...gen.Condition) *binDo {
	return b.withDO(b.DO.Having(conds...))
}

func (b binDo) Limit(limit int) *binDo {
	return b.withDO(b.DO.Limit(limit))
}

func (b binDo) Offset(offset int) *binDo {
	return b.withDO(b.DO.Offset(offset))
}

func (b binDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *binDo {
	return b.withDO(b.DO.Scopes(funcs...))
}

func (b binDo) Unscoped() *binDo {
	return b.withDO(b.DO.Unscoped())
}

func (b binDo) Create(values ...*model.Bin) error {
	if len(values) == 0 {
		return nil
	}
	return b.DO.Create(values)
}

func (b binDo) CreateInBatches(values []*model.Bin, batchSize int) error {
	return b.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (b binDo) Save(values ...*model.Bin) error {
	if len(values) == 0 {
		return nil
	}
	return b.DO.Save(values)
}

func (b binDo) First() (*model.Bin, error) {
	if result, err := b.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Bin), nil
	}
}

func (b binDo) Take() (*model.Bin, error) {
	if result, err := b.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Bin), nil
	}
}

func (b binDo) Last() (*model.Bin, error) {
	if result, err := b.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Bin), nil
	}
}

func (b binDo) Find() ([]*model.Bin, error) {
	result, err := b.DO.Find()
	return result.([]*model.Bin), err
}

func (b binDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Bin, err error) {
	buf := make([]*model.Bin, 0, batchSize)
	err = b.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (b binDo) FindInBatches(result *[]*model.Bin, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return b.DO.FindInBatches(result, batchSize, fc)
}

func (b binDo) Attrs(attrs ...field.AssignExpr) *binDo {
	return b.withDO(b.DO.Attrs(attrs...))
}

func (b binDo) Assign(attrs ...field.AssignExpr) *binDo {
	return b.withDO(b.DO.Assign(attrs...))
}

func (b binDo) Joins(fields ...field.RelationField) *binDo {
	for _, _f := range fields {
		b = *b.withDO(b.DO.Joins(_f))
	}
	return &b
}

func (b binDo) Preload(fields ...field.RelationField) *binDo {
	for _, _f := range fields {
		b = *b.withDO(b.DO.Preload(_f))
	}
	return &b
}

func (b binDo) FirstOrInit() (*model.Bin, error) {
	if result, err := b.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Bin), nil
	}
}

func (b binDo) FirstOrCreate() (*model.Bin, error) {
	if result, err := b.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Bin), nil
	}
}

func (b binDo) FindByPage(offset int, limit int) (result []*model.Bin, count int64, err error) {
	result, err = b.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = b.Offset(-1).Limit(-1).Count()
	return
}

func (b binDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = b.Count()
	if err != nil {
		return
	}

	err = b.Offset(offset).Limit(limit).Scan(result)
	return
}

func (b binDo) Scan(result interface{}) (err error) {
	return b.DO.Scan(result)
}

func (b binDo) Delete(models ...*model.Bin) (result gen.ResultInfo, err error) {
	return b.DO.Delete(models)
}

func (b *binDo) withDO(do gen.Dao) *binDo {
	b.DO = *do.(*gen.DO)
	return b
}
